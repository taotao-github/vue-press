# 6. 闭包

## 6.1 概念
> 闭包时一种呢特殊的对象。它是由两部分组成：执行上下文（代号A）以及执行上下文中的函数（代号B）。代号B执行时，如果访问了代号A中变量对象的值，那么闭包就会产生。在chrome中，闭包以A的执行上下文函数名代指闭包。

```javascript
// demo1
function foo() {
  var a = 20;
  var b = 30;
  function bar () {
    return a +b
  }
  return bar
}

var bar = foo();
bar()
```
上面这个例子中，首先执行foo执行上下文，里面bar函数。通过对外返回bar，在外部执行bar函数时，访问到foo变量对象中的a和b，此时就产生了闭包。使用chrome调试工具查看。

> 但没有执行bar函数时，闭包时没有产生的。

<img :src="$withBase('/images/javascript核心技术开发/demo1闭包产生之前.png')" alt="闭包产生之前" />

> 执行bar函数，产生闭包

<img :src="$withBase('/images/javascript核心技术开发/demo1闭包产生.png')" alt="闭包产生" />

::: tip 提示
Closure所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope 为当前正在被执行函数的作用域链，Local 为当前活动对象。
:::

**将demo1改动一下，demo2**
```javascript
// demo2
function foo() {
  var a = 20;
  var b = 30;
  function bar () {
    return a +b
  }
  bar()
}

foo();
```
按照概念可以，demo2也形成了闭包。foo执行上下文中定义bar函数，函数bar执行，访问到foo 变量对象中的a和b，因此在bar执行时函数时，也产生了闭包。

**在看一个有意思的例子**
```javascript
// demo3
function add(x) {
  return function _add(y){
    return x + y
  }
}

add(2)(3) // 5
```
这个例子中，当执行到_add函数时，访问到add变量对象中的x，因此就产生了闭包了。


**看看下面这段代码中是否有闭包产生**
```javascript
// demo4
var name = 'window'
var p = {
  name: 'Perter',
  getName: function() {
    return function() {
      return this.name
    }
  }
}

var getName = p.getName();
var _name = getName()
console.log(_name)
```
当getName()执行时，它的this指向的时window，这个时候并没有产生闭包的环境，因此此列没有闭包

**使用call改变this的执行，看看是否产生闭包**
```javascript
// demo5
var name = 'window'
var p = {
  name: 'Perter',
  getName: function() {
    return function() {
      return this.name
    }
  }
}

var getName = p.getName();
var _name = getName.call(p)
console.log(_name)
```
<img :src="$withBase('/images/javascript核心技术开发/demo5使用call改变this指向没有闭包产生.png')" alt="demo5使用call改变this指向没有闭包产生" />

通过chrome调试工具，可以看出此例并没有产生闭包。

**改动例子**
```javascript
// demo6
var name = 'window'
var p = {
  name: 'Perter',
  getName: function() {
    var self = this
    return function() {
      return self.name
    }
  }
}

var getName = p.getName();
var _name = getName()
console.log(_name)
```
<img :src="$withBase('/images/javascript核心技术开发/demo6使用变量保存改变this指向产生闭包产生.png')" alt="demo6使用变量保存改变this指向产生闭包产生" />

## 6.2 闭包与垃圾回收机制
> 闭包的本质是在函数外部保留了内部变量的引用，因此会阻止垃圾回收机制回收
```javascript
function f1() {
  var n = 999
  nAdd = function () {
    n += 1
  }
  return function f2 () {
    console.log(n)
  }
}

var result  = f1()
result() // 999
nAdd()
result() // 1000
```
nAdd 口都访问了 fl 中的 ，因此它们都与 fl 形成了闭包，因此变量n的引用就被保存下来了。f2和nAdd都能访问到他。

<img :src="$withBase('/images/javascript核心技术开发/闭包与垃圾回收.png')" alt="闭包与垃圾回收" />

## 6.3 闭包与作用域链
> 分析一下，闭包会导致函数的作用域链发生变化吗？
```javascript
var fn = null
function foo() {
  var a = 2;
  function innerFoo() {
    console.log(a)
  }
  fn = innerFoo // 将innerFoo的引用赋值给全局变量fn
}

function bar() {
  fn()
}

foo()

bar()
```
<img :src="$withBase('/images/javascript核心技术开发/闭包与作用域链.png')" alt="闭包与作用域链" />

因为函数调用战其实是在代码执行时才确定的，而作用域规则在代码编译阶段就已经确定，虽然作用域链是在代码执行时才生成的，但是它的规则并不会在执行时发生改变

## 6.4 在chrome开发工具中观察函数调用栈、作用域链和闭包
> 这里将要学习的 个非常重要的技能就叫作断点调试。通过断点调试，我们可以非常方便地步步观察 JavaScript 代码在执行过程中的细节变化 。我们能够直观地感知函数调用械、变量对象、作用域链、闭包、this等关键信息的变化过程。

<img :src="$withBase('/images/javascript核心技术开发/chrome断点.png')" alt="chrome断点" />

左侧区域为代码的函数，点击某一行可设置一个断点，也可通过debugger进行代码设定断点。右侧的图标是用于操作断点的，可以控制当前函数的执行进程。它们从左到右依次为：

1. **resume / pause script execution** 恢复或者暂停脚本执行
2. **step over next function call** 跨过，实际表示在未遇到函数时，执行下一步。遇到函数，不进入函数直接执行下一步
3. **step inner next function call** 跨入，实际表示在未遇到函数时，执行下一步。遇到函数，进入函数执行上下文
4. **step out of current function** 跳出当前函数
5. **deactivate breakpoints** 停用断点
6. **don't pause on exception** 不暂停异常捕获


